@router.post(
    "/api/v1/users/me/claim-registration",
    response_model=AttendeeClaimRegistrationResponse,
    status_code=status.HTTP_200_OK,
    summary="Authenticate User and Claim Registration ID",
    description="""Allows a user to log in with their email and password, and simultaneously claim their unique registration ID (reg_id) for a conference.
    If the reg_id is already claimed by this user, it will act as a successful login/confirmation.
    **(Currently uses plain-text password comparison for development)**"""
)
async def claim_registration(

    request_payload: AttendeeClaimRegistrationRequest,
    db: AsyncSession = Depends(get_db)
):
    # --- 1. User Authentication ---
    stmt = select(PgUser).filter(PgUser.email == request_payload.email)
    result = await db.execute(stmt)
    user = result.scalars().first()

    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid email or password.")

    # --- TEMPORARY: Direct password comparison (HIGHLY INSECURE FOR PRODUCTION) ---
    if request_payload.password != user.password_hash:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid email or password.")
    # --- END TEMPORARY ADJUSTMENT ---

    # Authentication successful, 'user' object now holds the authenticated user's data.

    # --- 2. Find Registration Record (regardless of claim status) ---
    # We first find the registration record, whether claimed or not.
    stmt_reg = select(UserRegistration).filter(
        UserRegistration.reg_id == request_payload.reg_id
    )
    result_reg = await db.execute(stmt_reg)
    registration_record = result_reg.scalar_one_or_none()

    if not registration_record:
        # If the reg_id doesn't exist at all in user_registrations
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Registration ID is invalid or does not exist."
        )

    # --- 3. Determine Action: Claim New or Confirm Existing ---
    try:
        if registration_record.user_id == user.user_id and registration_record.status == 'claimed':
            # Scenario A: Reg_id is ALREADY claimed by THIS authenticated user
            # Just confirm successful login and registration status, no DB update needed.
            action_message = "Logged in successfully. Registration already linked to your account."
            status_code_to_return = status.HTTP_200_OK # Success, but no new claim
            
            # Re-fetch conference name for response
            stmt_conf = select(PgConference).filter(PgConference.conference_id == registration_record.conference_id)
            result_conf = await db.execute(stmt_conf)
            conference = result_conf.scalar_one_or_none()
            conference_name_for_response = conference.name if conference else "Unknown Conference"

            return AttendeeClaimRegistrationResponse(
                message=action_message,
                user_id=user.user_id,
                claimed_reg_id=request_payload.reg_id,
                claimed_conference_id=registration_record.conference_id,
                conference_name=conference_name_for_response
            )

        elif registration_record.user_id is not None:
            # Scenario B: Reg_id is claimed by ANOTHER user
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT, # Conflict indicates it's taken
                detail="This registration ID has already been claimed by another account."
            )

        elif registration_record.status != 'pre_registered':
            # Scenario C: Reg_id exists but is in a state not available for claiming (e.g., 'cancelled')
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="This registration ID is not currently available for claiming."
            )
        
        else: # (registration_record.user_id is None and registration_record.status == 'pre_registered')
            # Scenario D: Reg_id is UNCLAIMED and 'pre_registered' - Proceed with claiming
            
            # Check if this user already has a reg_id in their users table and if you need to warn/prevent overwriting.
            # As per last discussion, we will overwrite `users.reg_id`.
            
            # Update the PgUserRegistration table: link the authenticated user to this reg_id
            registration_record.user_id = user.user_id # Link to the authenticated user
            registration_record.claimed_by_user_at = datetime.now(timezone.utc)
            registration_record.status = 'claimed'
            db.add(registration_record) # Stage the update

            # Update the PgUser table: set the user's primary reg_id field
            user.reg_id = request_payload.reg_id # Update the 'reg_id' column in the 'users' table
            db.add(user) # Stage the update

            await db.commit() # Commit all staged changes to the database
            await db.refresh(registration_record) # Refresh to get latest DB state
            await db.refresh(user) # Refresh user object

            # --- 4. Update Neo4j (Optional) ---
            stmt_conf = select(PgConference).filter(PgConference.conference_id == registration_record.conference_id)
            result_conf = await db.execute(stmt_conf)
            conference = result_conf.scalar_one_or_none()
            
            conference_name_for_response = "Unknown Conference" 
            if conference:
                await create_user_conference_registration_neo4j(
                    user_id=str(user.user_id),
                    conference_id=str(conference.conference_id),
                    reg_id=request_payload.reg_id 
                )
                conference_name_for_response = conference.name

            # --- 5. Return Success Response for New Claim ---
            return AttendeeClaimRegistrationResponse(
                message="Registration successfully claimed and account linked.",
                user_id=user.user_id,
                claimed_reg_id=request_payload.reg_id,
                claimed_conference_id=registration_record.conference_id,
                conference_name=conference_name_for_response
            )

    except HTTPException:
        raise # Re-raise FastAPI HTTPExceptions directly
    except Exception as e:
        await db.rollback() # Rollback all database changes if any other error occurs
        print(f"Error claiming registration for user {user.user_id} with reg_id {request_payload.reg_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred during registration claim. Please try again."
        )
